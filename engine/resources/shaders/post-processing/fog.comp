#version 430 core

layout(binding=0, rgba16f) uniform readonly image2D inputImage;
layout(binding=1, rgba32f) uniform readonly image2D gPosition;
layout(binding=2, rgba16f) uniform image2D outputImage;

uniform vec3 lightDirection;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std140, binding = 0) uniform screenData
{
	int viewportWidth;
	int viewportHeight;
	int multiSampling;
	float brightnessFactor;
};

layout(std140, binding = 1) uniform projectionData
{
    mat4 viewProjection;    // size = 64B
    mat4 projectionMatrix;    // size = 64B
    mat4 viewMatrix;    // size = 64B
    vec3 cameraPosition;    // size = 16B
};

vec3 applyFog( vec3 rgb,      // original color of the pixel
               float distance, // camera to point distance
               vec3 rayDir,   // camera to point vector
               vec3 sunDir )  // sun light direction
{
    float falloff = 0.0033;
    float globalDensity = 1;
    float cameraElevation = cameraPosition.y;

    float c = globalDensity/falloff;
    float fogAmount =  exp(- cameraElevation * falloff ) * (1.0-exp( -distance * rayDir.y* falloff )) / rayDir.y;

    float sunAmount = max( dot( rayDir, sunDir)/2, 0.0 );
    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish
                           vec3(1.0,0.9,0.7), // yellowish
                           sunAmount );

    float fac = max( dot( rayDir, normalize(vec3(rayDir.x,0,rayDir.z))) / 4, 0.0 );
    fac = pow(fac, 2.0);
    return mix(rgb, fogColor, clamp(fogAmount * fac, 0, 1));
}

void main()
{
    vec3 FragPos = imageLoad(gPosition, ivec2(gl_GlobalInvocationID.xy)).rgb;
    vec3 color = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.xy)).rgb;

    vec3 outputColor = applyFog(color, length(FragPos-cameraPosition), normalize(FragPos-cameraPosition), -lightDirection);

    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(outputColor, 1));
}
